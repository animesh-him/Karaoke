<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Instrumental Maker</title>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Pacifico&display=swap" rel="stylesheet">

<style>
body{
  margin:0;
  min-height:100vh;
  font-family:Poppins,sans-serif;
  color:#fff;
  background:linear-gradient(270deg,#ff00cc,#3333ff,#00ffd5);
  background-size:600% 600%;
  animation:bg 12s ease infinite;
}
@keyframes bg{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}
.container{
  max-width:420px;
  margin:auto;
  padding:20px;
  text-align:center;
}
button,input{
  width:100%;
  margin:10px 0;
}
button{
  padding:12px;
  border:none;
  border-radius:22px;
  background:rgba(255,255,255,.2);
  color:white;
  font-size:14px;
}
audio{
  width:100%;
  margin-top:10px;
}
.footer{
  margin-top:25px;
  font-family:Pacifico,cursive;
  opacity:.8;
}
</style>
</head>

<body>
<div class="container">
  <h2>Instrumental Creator</h2>

  <input type="file" id="file" accept="audio/*">

  <button id="create" disabled>Create Instrumental</button>

  <audio id="output" controls></audio>

  <div class="footer"><i>created by Animesh</i></div>
</div>

<script>
let audioCtx;
let sourceBuffer;

file.addEventListener("change", async e=>{
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const arrayBuffer = await e.target.files[0].arrayBuffer();
  sourceBuffer = await audioCtx.decodeAudioData(arrayBuffer);
  create.disabled = false;
});

create.addEventListener("click", async ()=>{
  // REQUIRED for mobile browsers
  await audioCtx.resume();

  const channels = sourceBuffer.numberOfChannels;
  const length = sourceBuffer.length;
  const rate = sourceBuffer.sampleRate;

  // Always render MONO instrumental so it works everywhere
  const offline = new OfflineAudioContext(1, length, rate);
  const output = offline.createBuffer(1, length, rate);

  const left = sourceBuffer.getChannelData(0);
  const right = channels > 1 ? sourceBuffer.getChannelData(1) : left;

  const out = output.getChannelData(0);

  // CENTER CANCELLATION (L - R)
  for(let i=0;i<length;i++){
    out[i] = (left[i] - right[i]) * 0.7;
  }

  const src = offline.createBufferSource();
  src.buffer = output;
  src.connect(offline.destination);
  src.start();

  const rendered = await offline.startRendering();
  const wavBlob = bufferToWav(rendered);

  outputAudio(wavBlob);
});

/* -------- WAV ENCODER (RELIABLE PLAYBACK) -------- */
function bufferToWav(buffer){
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const samples = buffer.getChannelData(0);
  const length = samples.length;

  const bufferArray = new ArrayBuffer(44 + length * 2);
  const view = new DataView(bufferArray);

  function writeString(offset, str){
    for(let i=0;i<str.length;i++){
      view.setUint8(offset+i, str.charCodeAt(i));
    }
  }

  writeString(0,"RIFF");
  view.setUint32(4,36 + length*2,true);
  writeString(8,"WAVE");
  writeString(12,"fmt ");
  view.setUint32(16,16,true);
  view.setUint16(20,1,true);
  view.setUint16(22,numChannels,true);
  view.setUint32(24,sampleRate,true);
  view.setUint32(28,sampleRate*numChannels*2,true);
  view.setUint16(32,numChannels*2,true);
  view.setUint16(34,16,true);
  writeString(36,"data");
  view.setUint32(40,length*2,true);

  let offset = 44;
  for(let i=0;i<length;i++){
    let s = Math.max(-1,Math.min(1,samples[i]));
    view.setInt16(offset, s<0?s*0x8000:s*0x7fff, true);
    offset += 2;
  }

  return new Blob([view], {type:"audio/wav"});
}

function outputAudio(blob){
  const url = URL.createObjectURL(blob);
  output.src = url;
  output.load();
}
</script>
</body>
</html>
